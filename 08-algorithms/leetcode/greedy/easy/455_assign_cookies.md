# 455. 分发饼干（Assign Cookies）

[题目链接](https://leetcode.com/problems/assign-cookies/)

## 题目描述
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j]。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例：
```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 你有三个孩子和两块小饼干，三个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 你有两个孩子和三块小饼干，两个孩子的胃口值分别是1,2。
你拥有的饼干数组里面有1,2,3。
你可以给第一个孩子分配1号饼干，给第二个孩子分配2号饼干。
每个孩子都得到了他想要的饼干，所以你应该输出2。
```

## 解法：贪心算法

### 思路
1. 对孩子的胃口值和饼干尺寸进行排序
2. 用尽量小的饼干满足胃口小的孩子
3. 从小到大遍历，尽可能满足更多的孩子

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        // 对胃口和饼干尺寸排序
        Arrays.sort(g);
        Arrays.sort(s);
        
        int child = 0;  // 已满足的孩子数量
        int cookie = 0;  // 当前尝试的饼干索引
        
        // 遍历每个饼干
        while (cookie < s.length && child < g.length) {
            // 当前饼干可以满足当前孩子
            if (s[cookie] >= g[child]) {
                child++;
            }
            cookie++;
        }
        
        return child;
    }
}
```

### 复杂度分析
- 时间复杂度：O(nlogn)，其中n是数组的长度，主要是排序的复杂度
- 空间复杂度：O(1)，只使用了常数额外空间

## 解法二：双指针优化

### 思路
使用双指针同时遍历孩子和饼干数组，可以使代码更清晰。

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        
        int i = 0;  // 孩子指针
        int j = 0;  // 饼干指针
        int count = 0;  // 满足的孩子数量
        
        while (i < g.length && j < s.length) {
            if (s[j] >= g[i]) {
                count++;
                i++;
            }
            j++;
        }
        
        return count;
    }
}
```

## 题目重点
1. 理解贪心策略：用尽量小的饼干满足胃口小的孩子
2. 排序的必要性
3. 指针移动的条件

## 解题技巧

### 1. 排序预处理
```java
// 对数组排序是贪心算法的常见预处理步骤
Arrays.sort(g);  // 胃口值排序
Arrays.sort(s);  // 饼干尺寸排序
```

### 2. 贪心策略选择
```java
// 当前饼干满足当前孩子时才移动孩子指针
if (s[j] >= g[i]) {
    i++;  // 移动到下一个孩子
}
j++;  // 无论是否满足都尝试下一个饼干
```

### 3. 结果统计
```java
// 方式1：使用计数变量
int count = 0;
if (condition) count++;

// 方式2：直接使用指针作为结果
return childIndex;  // childIndex就是满足的孩子数量
```

## 相关题目
- [135. 分发糖果](https://leetcode.com/problems/candy/)
- [330. 按要求补齐数组](https://leetcode.com/problems/patching-array/)
- [1518. 换酒问题](https://leetcode.com/problems/water-bottles/)

## 延伸思考

### 1. 变种问题
- 如果每个孩子可以拿多个饼干？
- 如果饼干可以分割？
- 如果要求最小化浪费的饼干大小？

### 2. 优化方向
- 避免不必要的排序
- 处理特殊输入
- 提前返回机制

### 3. 实际应用
- 资源分配问题
- 任务调度
- 物品匹配

## 面试技巧

### 1. 思路讲解
1. 先说明贪心策略
2. 解释排序的必要性
3. 分析算法复杂度
4. 提供优化建议

### 2. 代码实现
- 变量命名要有意义
- 添加必要的注释
- 处理边界情况
- 保持代码简洁

### 3. 性能分析
- 时间复杂度分析
- 空间使用分析
- 优化可能性讨论

## 常见错误

### 1. 排序遗漏
```java
// 错误：忘记对数组排序
while (i < g.length && j < s.length) {
    // ...
}
```

### 2. 指针移动错误
```java
// 错误：指针移动条件写反
if (s[j] >= g[i]) {
    j++;  // 应该是i++
}
```

### 3. 边界处理错误
```java
// 错误：没有检查数组是否为空
if (g == null || s == null) {
    return 0;
}
```

## 总结

### 1. 解题步骤
- 理解问题本质
- 确定贪心策略
- 实现基本逻辑
- 优化代码结构

### 2. 关键点
- 排序的必要性
- 贪心策略证明
- 指针移动逻辑
- 代码简洁性

### 3. 技能提升
- 贪心思维训练
- 代码规范性
- 问题分析能力
- 优化意识
